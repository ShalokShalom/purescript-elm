
-- | It is often convenient, even necessary, to compare two functions in order to
-- | determine whether they are equal. This is, sadly, impossible, in the general
-- | case -- that is, impossible if you know nothing about where the function came
-- | from.
-- |
-- | However, it is possible to determine that two functions came from the same
-- | place -- that is, that they are the same function. One way to do this is via
-- | referential equality in the FFI. However, there are at least two problems
-- | with this:
-- |
-- | * It is, in principle, fragile in the face of optimizations that the compiler
-- |   may or may not do.
-- |
-- | * It does not always compose well. Of course, if two referentially-equal functions are
-- |   composed at the top-level, that is done once, and the resulting function will
-- |   be referentially equal to itself. However, if the referentially-equal functions
-- |   are composed under other circumstances, it is possible for a new function to
-- |   be created each time -- not referentially equal, even though we could infer
-- |   equality.
-- |
-- | So, what to do? The idea this module expresses is that we can make a kind
-- | of reference equality less fragile by "wrapping" a function with a new type
-- | -- `EqFn` -- which contains a unique tag. Given the unique tag, we
-- | can equate the wrapper -- and thus, by necessary implication, the function inside.
-- |
-- | We can also provide for robust composition of the `EqFn`, preserving
-- | the ability to equate the composed function.
-- |
-- | So, in cases where you need to equate functions, you can ask for a `EqFn`
-- | instead. If two `EqFn` are equal, then the functions inside are
-- | necessarily equal.
-- |
-- | Now, if two `EqFn` are unequal, it is still possible for the wrapped
-- | functions to be equal, in the sense that they may be defined (separately) in the
-- | same way. So, for best results, you need to follow certain rules which
-- | are specified in the documentation for `mkEqFn` and `runEqFn`.

module Data.Function.Equatable
    ( EqFn, type (==>), mkEqFn, runEqFn
    ) where


import Data.List (List(..), (:))
import Prelude (class Eq, eq, class Semigroupoid, compose, class Category, id, (<>))


data EqFn a b = EqFn (a -> b) (List Int)

infixr 4 type EqFn as ==>


-- | Given a top-level function, make an equatable function.
-- |
-- | For best results, the function you provide should be defined at the top-level
-- | of your module, rather than being the value returned by another function. The
-- | problem if your function is generated by another function is that you'll get a
-- | differnt `EqFn` every time. So, they will never be equal to each other, even if
-- | we know that they must be.
-- |
-- | As far as I know, there isn't any way in the type system to enforce that the
-- | incoming function has not been produced by another function. So, you just have to
-- | verify that for yourself.
mkEqFn :: ∀ a b. (a -> b) -> EqFn a b
mkEqFn func =
    EqFn func (Cons (tag func) Nil)


-- Gets a unique tag for a function. Stores the tag as a property on the function, so
-- that if we call tag again on the same function, we get the same value.
foreign import tag :: ∀ a b. (a -> b) -> Int


-- | Once you have an `EqFn`, you can use `runEqFn` to apply the function to an
-- | argument.
-- |
-- | I suppose you can also extract the `Function` itself, given
-- | partial application. Note that you shouldn't supply such an extracted
-- | function back into `mkEqFn`, since that would have the problems mentioned
-- | in the documentation for `mkEqFn`.
-- |
-- | So, basically, you should:
-- |
-- | * Start with a top-level functions, and use `mkEqFn` to
-- |   prodduce `EqFn`.
-- |
-- | * If you want to produce a new `EqFn` based on an `EqFn`, do it by
-- |   manipulating the `EqFn`.
-- |
-- | * Only use `runEqFn` to actually perform the calculation.
runEqFn :: ∀ a b. EqFn a b -> a -> b
runEqFn (EqFn func _) = func


instance eqEqFn :: Eq (EqFn a b) where
    eq (EqFn _ tags1) (EqFn _ tags2) = eq tags1 tags2


instance semigroupoidEqFn :: Semigroupoid EqFn where
    compose (EqFn func1 tags1) (EqFn func2 tags2) =
        EqFn (compose func1 func2) (tags1 <> tags2)


instance categoryEqFn :: Category EqFn where
    -- So, our func is the usual `id`. The trick is that our
    -- tag is empty, so that when we compose with another
    -- `EqFn` we take on its tags, which of course is correct,
    -- since we're not modifying that function. Nice, eh?
    id = EqFn id Nil

